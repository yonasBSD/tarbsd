<?php declare(strict_types=1);
namespace TarBSD\Builder;

use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Process\Process;
use Symfony\Component\Finder\Finder;

use TarBSD\Util\Fstab;
use TarBSD\Util\Misc;

/**
 * MFS image has sort of two images actually.
 * "Outer" image contains just the kernel
 * tarfs.ko and perhaps some other modules.
 * It loads the "inner" image to the memory.
 * 
 * This class might at some point get a
 * sister class, that doesn't have this
 * nesting and requires boot volume to
 * to stay present.
 */
class MfsBuilder extends AbstractBuilder
{
    protected function getKernelModuleDirs() : array
    {
        $dirs = parent::getKernelModuleDirs();
        $dirs[] = $this->wrk . '/boot/boot/kernel';
        return $dirs;
    }

    protected function genFsTab() : Fstab
    {
        $fstab = new Fstab;
        $fstab->addLine('/dev/md0', '/', 'ufs', 'rw');
        return $fstab;
    }

    protected function prepare(OutputInterface $output, OutputInterface $verboseOutput, bool $quick, string $platform) : void
    {
        $fs = $this->fs;

        $fs->remove($efiDir = $this->wrk . '/efi');
        $fs->remove($boot = $this->wrk . '/boot');

        $fs->mkdir($efiDir . '/EFI/BOOT');

        $fs->mkdir($boot . '/boot/kernel');

        if ($fs->exists($hostId = $this->root . '/etc/hostid'))
        {
            $fs->copy($hostId , $boot . '/etc/hostid');
        }

        foreach([
            'boot/lua'                  => true,
            'boot/defaults'             => true,
            'boot/kernel/kernel'        => true,
            'boot/kernel/tarfs.ko'      => true,
            'boot/kernel/linker.hints'  => false,
            'boot/device.hints'         => false
        ] as $file => $take) {
            $src = $this->root . '/' . $file;
            if ($take)
            {
                $fs->rename($src, $boot . '/' . $file);
            }
            elseif ($fs->exists($src))
            {
                $fs->copy($src, $boot . '/' . $file);
            }
        }
        if ($platform === 'amd64')
        {
            $fs->rename($this->root . '/boot/loader_lua', $boot . '/boot/loader');
            $fs->rename($this->root . '/boot/loader.efi', $efiDir . '/EFI/BOOT/BOOTX64.efi');
            Process::fromShellCommandline(
                'makefs -t msdos -s 748k -o fat_type=12,sectors_per_cluster=1,volume_label=EFISYS efi.img efi',
                $this->wrk
            )->mustRun();
            foreach(['pmbr', 'gptboot'] as $legacyBootFile)
            {
                $fs->rename($this->root . '/boot/' . $legacyBootFile, $this->wrk . '/cache/' . $legacyBootFile, true);
            }
        }
        elseif ($platform === 'aarch64')
        {
            $fs->rename($this->root . '/boot/loader_lua.efi', $boot . '/boot/loader.efi');
            $fs->rename($this->root . '/boot/loader.efi', $efiDir . '/EFI/BOOT/BOOTAA64.efi');
            Process::fromShellCommandline(
                'makefs -t msdos -s 960k -o fat_type=12,sectors_per_cluster=1,volume_label=EFISYS efi.img efi',
                $this->wrk
            )->mustRun();
        }
        else
        {
            throw new \Exception;
        }

        $load = ['tarfs'];
        $finder = new Finder;
        $finder->files()->in([$this->root . '/boot/kernel', $this->root . '/boot/modules']);

        foreach(($modules = $this->getEarlyModules()) as $module)
        {
            $finder = $finder->name($module);
        }

        if ($modules)
        {
            foreach($finder as $file)
            {
                $this->fs->rename((string) $file, $boot . '/boot/kernel/' . $file->getFilename());
                $load[] = substr($file->getBasename(), 0, -3);
            }
        }

        $loaderConf = <<<CONF
mfs_load="YES"
mfs_type="mfs_root"
mfs_name="/mfsroot"
vfs.root.mountfrom="ufs:/dev/md0"
beastie_disable="YES"
autoboot_delay="3"
entropy_cache_load="NO"
vfs.zfs.min_auto_ashift=12

CONF;

        foreach($load as $ext)
        {
            $loaderConf .= "\n" . $ext . '_load="YES"';
        }

        if ($this->fs->exists($existing = $this->root . '/boot/loader.conf'))
        {
            $loaderConf .= "\n# lines above this were auto-generated by tarBSD builder";
            $loaderConf .= "\n\n" . file_get_contents($existing);
        }
        $fs->dumpFile($boot . '/boot/loader.conf', $loaderConf);

        $this->gzipFiles((new Finder)->files()->in(
            $boot . '/boot/kernel'
        )->name(['kernel', '*.ko']), $output, $verboseOutput, $quick);
    }

    protected function pruneBoot(OutputInterface $output, OutputInterface $verboseOutput) : void
    {
        $finder = new Finder;
        $finder->files()
            ->in($this->root . '/boot')
            ->notName('*.ko')
            ->notName('*.hints');
        $this->fs->remove($finder);

        $finder = new Finder;
        $finder->directories()
            ->in($this->root . '/boot')
            ->notName('kernel')
            ->notName('modules');
        $this->fs->remove($finder);

        $finder = new Finder;
        $finder->files()->in([
            $this->root . '/boot/kernel',
            $this->root . '/boot/modules',
        ])->notName('*.hints');

        foreach($this->getModules() as $ext)
        {
            $finder = $finder->notName($ext);
        }

        $this->fs->remove($finder);
    }

    protected function buildImage(OutputInterface $output, OutputInterface $verboseOutput, bool $quick, string $platform) : void
    {
        $zstdLevel = $quick ? 12 : 19;
        $gzipLevel = $quick ? 6 : 9;

        // copy loader.conf to the mfs image too
        // for documentation purposes
        $this->fs->copy(
            $this->wrk . '/boot/boot/loader.conf',
            $this->root. '/boot/loader.conf'
        );

        $this->fs->mkdir($this->root . '/usr/.root/bin');
        $this->fs->mkdir($this->root . '/usr/.root/sbin');
        $this->fs->mkdir($this->root . '/usr/.root/lib');
        $this->fs->mkdir($this->root . '/usr/.root/etc');
        $this->fs->mkdir($this->root . '/usr/.root/var/db');

        /**
         * todo: insted of writing a shell script with PHP,
         * do things in PHP.
         */
        $optimizations = [
            'mv boot usr/.root/', // it compresses better here
            'ln -s usr/.root/boot .',
            'mv var/db/services.db usr/.root/var/db',
            'ln -s ../../usr/.root/var/db/services.db var/db/services.db',
        ];

        if (true) // could this break something? Optional perhaps?
        {
            $optimizations = $this->extraOptimizations($optimizations);
        }

        Process::fromShellCommandline(
            implode("\n", $optimizations),
            $this->root
        )->mustRun();

        $tarOptions = Misc::encodeTarOptions([
            'compression-level' => $zstdLevel,
            'min-frame-in'      => '512k',
            /**
             * Is there a noticeable performace penalty
             * if this is set to more than kern.maxphys?
             */
            'max-frame-in'      => '1M',
            'frame-per-file'    => true,
            'threads'           => 0
        ]);

        $progressIndicator = $this->progressIndicator($output);
        $this->wrkFs->tightCompression(false);
        $progressIndicator->start('compressing usr.tar (zstd-' . $zstdLevel . ')');
        Process::fromShellCommandline(
            "tar -v --zstd --options zstd:$tarOptions -cf ../.usr.tar * .root",
            $this->root . '/usr',
            null, null, 7200
        )->mustRun(function ($type, $buffer) use ($progressIndicator, $verboseOutput)
        {
            $progressIndicator->advance();
            $verboseOutput->write($buffer);
        });
        $progressIndicator->finish('usr.tar ready');
        $this->wrkFs->tightCompression(true);

        $umountUsr = Process::fromShellCommandline(
            'umount -f usr',
            $this->root,
        );

        $this->wrkFs->checkSize(Misc::getFileSizeM($this->root) - Misc::getFileSizeM($this->root . '/usr'));
        try
        {
            Process::fromShellCommandline(
                'mount -t tmpfs -o size=1m tmpfs root/usr && makefs -b 5% boot/mfsroot root && rm root/.usr.tar',
                $this->wrk,
                null, null, 1800
            )->mustRun(function ($type, $buffer) use ($verboseOutput)
            {
                $verboseOutput->write($buffer);
            });
        }
        catch (\Exception $e)
        {
            $umountUsr->mustRun();
            throw $e;
        }
        $umountUsr->mustRun();

        $this->wrkFs->checkSize();
        $progressIndicator = $this->progressIndicator($output);
        $progressIndicator->start('compressing mfs image (gzip-' . $gzipLevel . ')');
        Misc::zlibCompress($this->wrk . '/boot/mfsroot', $gzipLevel, $progressIndicator);
        $progressIndicator->finish('mfs image ready');

        $this->writeFile($output, $verboseOutput, $platform);
    }

    protected function writeFile(OutputInterface $output, OutputInterface $verboseOutput, string $platform) : void
    {
        $progressIndicator = $this->progressIndicator($output);
        $progressIndicator->start('writing image');

        $this->wrkFs->checkSize(Misc::getFileSizeM($this->wrk . '/boot'));

        Process::fromShellCommandline(
            'makefs boot.img boot && rm boot/mfsroot.gz',
            $this->wrk,
            null, null, 1800
        )->mustRun(function ($type, $buffer) use ($verboseOutput, $progressIndicator)
        {
            $verboseOutput->write($buffer);
            $progressIndicator->advance();
        });

        $size = Misc::getFileSizeM($this->wrk . '/boot.img');
        $this->wrkFs->checkSize($size);
        Misc::truncate($disk = $this->wrk . '/tarbsd.img', ($size + 1) * 1024 * 1024);
        $md = $this->md = Misc::mdCreate($disk);
        $size = strval($size) . 'm';

        if ($platform === 'amd64')
        {
            $gpartCmd = <<<CMD
gpart create -s gpt $md
gpart add -b 40 -s 472 -t freebsd-boot $md
gpart add -t efi -s 748k $md
gpart add -t freebsd-ufs -s $size $md
gpart bootcode -b cache/pmbr -p cache/gptboot -i 1 $md
CMD;
            $efiDev = '/dev/' . $md . 'p2';
            $bootDev = '/dev/' . $md . 'p3';
        }
        elseif ($platform === 'aarch64')
        {
            $gpartCmd = <<<CMD
gpart create -s gpt $md
gpart add -t efi -s 960k $md
gpart add -t freebsd-ufs -s $size $md
CMD;
            $efiDev = '/dev/' . $md . 'p1';
            $bootDev = '/dev/' . $md . 'p2';
        }
        else
        {
            throw new \Exception;
        }

        try
        {
            Process::fromShellCommandline(
                $gpartCmd, $this->wrk, null, null,  300
            )->mustRun(function ($type, $buffer) use ($verboseOutput, $progressIndicator)
            {
                $verboseOutput->write($buffer);
                $progressIndicator->advance();
            });
            Misc::dd($this->wrk . '/efi.img', $efiDev, $progressIndicator);
            Misc::dd($this->wrk . '/boot.img', $bootDev, $progressIndicator);
        }
        catch (\Exception $e)
        {
            Misc::mdDestroy($this->md);
            throw $e;
        }
        $progressIndicator->finish('image written');
        Misc::mdDestroy($this->md);
        $this->fs->remove($this->wrk . '/efi.img');
        $this->fs->remove($this->wrk . '/boot.img');
        $this->fs->remove($this->wrk . '/cache/pmbr');
        $this->fs->remove($this->wrk . '/cache/gptboot');
        $this->md = null;
    }

    /**
     * Moves some files from /bin, /sbin and /lib
     * to /usr where they get better compression.
     * 
     * Could this break something?
     */
    protected function extraOptimizations(array $optimizations) : array
    {
        // sbin
        foreach((new Finder)->files()->in(
            $this->root . '/sbin'
        ) as $sbin)
        {
            if (preg_match('/^('
                . 'bec|pf|pi|ip|if|mdc|ip|mount_'
                . '|fsck_ms|route|newfs|has|g|cam|z|dhclient'
                . '|fsd|fsi|dn|re|rr|rt|quo|ether|ff|fd'
                . '|shut|nvme|fas|set|save|umount'
            . ')/', $sbin->getFileName())
            && !$sbin->isLink()
            ) {
                $optimizations[] = 'mv sbin/' . $sbin->getFileName() . ' usr/.root/sbin/';
            }
        }
        $optimizations[] = 'cd sbin && ln -s ../usr/.root/sbin/* . && cd ..';

        // lib
        $finder = (new Finder)->in(
            $this->root . '/lib'
        )->notname([
            'libc.so*', 'libutil.so*', 'libxo.so*', 'libedit.so*', 'libtinfow.so*',
            'libjail.so*', 'libmd.so*', 'libcasper.so*', 'libnv.so*', 'libcap_fileargs.so*',
            'libm.so*'
        ])->depth(0);
        $libs = array_map(function($f) {
            return $f->getFileName();
        }, array_values(iterator_to_array($finder)));
        foreach($libs as $lib)
        {
            $optimizations[] = 'mv lib/' . $lib . ' usr/.root/lib/';
        }
        $optimizations[] = 'cd lib && ln -s ../usr/.root/lib/* . && cd ..';

        $this->fs->rename(
            $this->root . '/bin/csh',
            $csh = $this->root . '/usr/.root/bin/csh'
        );
        $this->fs->hardlink(
            $csh,
            dirname($csh) . '/tcsh'
        );
        $this->fs->remove($this->root . '/bin/tcsh');

        foreach((new Finder)->files()->in(
            $this->root . '/bin'
        )->name([
            'pax', 'ps', 'ed', 'dd', 'rmail', 'uuidgen', 'setfacl',
            'red', 'expr', 'chio', 'cpuset', 'cat', 'date', 'ls',
            'cp', 'mv', 'chmod', 'rmail', 'freebsd-version', 'pwait',
            'nproc', 'getfacl', 'domainname', 'df', 'chflags'
        ]) as $bin)
        {
            if (!$bin->isLink())
            {
                $bin = $bin->getFileName();
                $optimizations[] = 'mv bin/' . $bin . ' usr/.root/bin/';
            }
        }
        $optimizations[] = 'cd bin && ln -s ../usr/.root/bin/* . && cd ..';

        return $optimizations;
    }
}
